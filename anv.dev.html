<!DOCTYPE html>
<meta charset="utf-8">

<!--
<script src="//d3js.org/d3.v3.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
-->
<style>i

.title {
	fill: hsla(0,0,5,.5);
	font: 20px arial, sans serif;

}
	

.background {
  fill: #EBF5FF;
  pointer-events: all;
}

.active {
	fill: #E65C5C;
}


.featured { fill: #DA4545;  }

#hurr {
	stroke-dasharray: 3,2;
}

#countries { fill: #F8F0D9; }
.boundary {
	fill: none;
	stroke: #C6C0AE; // #fed98e;
	stroke-width: 1px;
	stroke-opacity: 1;
	
}
.boundary_zoom {
	fill: none;
	stroke: #C6C0AE;
	stroke-width: .5px;
}

.dialogBox {
	display: inline-block;
	background-color: teal;
	margin-right: 2px;
	position: fixed;
	top: 485px;
	left: 0px;
    height: 10px;
	width: 100px;
	z-index:100;
}

.hide {
	fill: none;
}

.feature {
	fill: #DA4545;
}

.active_boundary {
	fill: none;
	stroke: #FFFFFF; //#C6C0AE; 
	stroke-width: .07px;
//	stroke-opacity: .75;
}	

.graticule {
  fill: none;
  stroke: #777;
  stroke-width: .3px;
  stroke-opacity: .9;
} 

.face {
opacity: .8;
}

.faceOff {
opacity: 0;
}

</style>

<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="http://d3js.org/colorbrewer.v1.min.js"></script>
<script src="http://d3js.org/d3.geo.projection.v0.min.js" charset="utf-8"></script>

<script>

//options needs to be created via looping through country files to determine types of content. For now created expressly
var options = ["Read","Watch"];

var featured = ["PHL"];

/*function httpGet(theURL){
    var xmlHttp = null;
		
    xmlHttp = new XMLHttpRequest();
    xmlHttp.open( "GET", theURL, false );
    xmlHttp.send( null );
    return xmlHttp.responseText;
};
*/	



var width = 938,
    height = 480,
    country,
    state;

var graticule = d3.geo.graticule();

var projection = d3.geo.cylindricalEqualArea()
//var projection = d3.geo.mtFlatPolarQuartic()

	.parallel(35.5)
    .scale(200)
    .translate([width / 2, height / 1.9]);

var trackWidth = .5;

var color = d3.interpolateLab("#99d594", "#fc8d59");

var path = d3.geo.path()
	.projection(projection);

var svg = d3.select("body").append("svg")
	.attr("width", width)
	.attr("height", height);

//var checkcontent = function (i) {
	

//var options = d3.select("body").append



svg.append("rect")
	.attr("class", "background")
	.attr("width", width)
	.attr("height", height)
	.on("click", country_clicked); 


var g = svg.append("g");



/*svg.append("path")
//	g.append("g")	
	.datum(graticule)
	.attr("class","background")
	.attr("d",path);
*/

d3.json("countries_min.topo.json", function(error, us) {
		g.append("g")
		.attr("id", "countries")
		.selectAll("path")
		.data(topojson.feature(us, us.objects.countries_min).features)
		.enter()
			.append("path")
			.attr("class", function(d) {
				var c = "";
				if (featured.indexOf(d.id) > -1) {
					c = "featured";
					var centroid = path.centroid(d);
					svg.append("image")
						.attr("xlink:href","data/phl/face.png")
						.attr("width", "40px")
						.attr("height", "40px")
						.attr("class", "face")	
						.attr("x", centroid[0] + 5)
						.attr("y", centroid[1] - 30) ; 




					} else {
					c = "country";
					}
					return c; 
					})
			.attr("id", function(d) { return d.id; })

			.attr("d", path)
			.on("click", country_clicked);
	
		g.insert("g")
			.datum(topojson.mesh(us, us.objects.countries_min, function(a, b) {
			return a !== b; 
		}))
		.append("path")
		.attr("class", "boundary")
		.attr("d", path);

	

		});
/*
var cntry = document.getElementsByClassName("country");
var countryArray =[]; countryArray.length = cntry.length;
for (var i = 0; i < countryArray.length; i++) {
	countryArray[i] = cntry[i];
};
		
console.log(cntry);
*/


function zoom(xyz) {
	g.transition()
		.duration(750)
		.attr("transform", "translate(" + projection.translate() + ")scale(" + xyz[2] + ")translate(-" + xyz[0] + ",-" + xyz[1] + ")")
		.selectAll(["#countries", "#states"])
		.style("stroke-width", 1.0 / xyz[2] + "px")
		.selectAll(".city")
		.attr("d", path.pointRadius(20.0 / xyz[2]));


		g.selectAll(".boundary").classed("boundary_zoom",true);

}

function get_xyz(d) {
	var bounds = path.bounds(d);
	var w_scale = (bounds[1][0] - bounds[0][0]) / width;
	var h_scale = (bounds[1][1] - bounds[0][1]) / height;
	var z = .96 / Math.max(w_scale, h_scale);
	var x = (bounds[1][0] + bounds[0][0]) / 2;
	var y = (bounds[1][1] + bounds[0][1]) / 2 + (height / z / 6);
	return [x, y, z];
}

/*
console.log(g.selectAll(".featured").each(function (d) {
	var centroid = path.centroid(d);
	return centroid;
	}));
*/


function country_clicked(d) {
	g.selectAll(["#states", "#cities"]).remove();
	state = null;

	if (country) {
		g.selectAll( "#" + country.id ).style('display', null);

	}	

	if (d && country !== d) {
		var xyz = get_xyz(d);
		country = d;



		if ( d.id == 'PHL') {
		console.log(d)
		console.log(path.centroid(d));
		svg.selectAll(".face").classed("faceOff",true);
		svg.selectAll(".faceOff").classed("face",false);

		d3.select("body").selectAll("div")
			.append("div")
			.attr("class","title")
			.style({"height":"20px", "top":"10px"})
			.html("watch");
	
			


	
	/*	d3.select("body").selectAll("div")
			.data(options)
			.enter()
			.append("div")
			.attr("class","dialogBox")
			.transition()
			.delay(50)
			.each("start", function() {d3.select(this).style("height","10px");})
			.style({"height":"20px", "left": function(d){
				(((options.indexOf(d) * 100) + 2).toString() + "px" );
				}
			})
*/

			


			g.selectAll( "#" + country.id ).classed(".hide");
			
				
			d3.json("data/json/states_" + d.id.toLowerCase() + ".topo.json", function(error, us) {
				g.append("g")
          			.attr("id", "states")
          			.selectAll("path")
          			.data(topojson.feature(us, us.objects.states).features)
          			.enter()
          			.append("path")
          			.attr("id", function(d) { return d.id; })
          			.attr("class", "active")
          			.attr("d", path)
  					/*  .on("click", state_clicked);     */
					var hurrZoomFactor = [1,1,.5];
					for(var i=0; i < hurrZoomFactor.length; i++) {
						xyz[i] = hurrZoomFactor[i] * xyz[i];
					}

				g.insert("g")
					.datum(topojson.mesh(us, us.objects.states, function(a, b) {
						return a !== b; 
					}))
					.append("path")
					.attr("class", "active_boundary")
					.attr("d", path);
        		zoom(xyz);

  //      		g.selectAll("#" + d.id).style('display', 'none');
      		});      
			

			d3.json("data/" + d.id.toLowerCase() + "/track.json", function(error, track) {

					var color_scale = d3.scale.quantile().domain([3,5]).range(colorbrewer.Reds[5]);
					

					var dateText = svg.append("text")
						.attr("id", "dataTitle")
						.text("2013" + " " + track[0].month + " " + track[0].day + " " + track[0].hour + ":00 class: " + track[0].class)
						.attr("x", 650)
						.attr("y", 20)
						.attr("font-family", "sans-serif")
						.attr("font-size", "20px")
						.attr("fill", color_scale(track[0].class));

					var line = d3.svg.line()
						.interpolate("cardinal")
						.x(function(d) {return projection([d.lon, d.lat])[0]; })
						.y(function(d) {return projection([d.lon, d.lat])[1]; });

					var baseHurrPath = svg.append("path")
						.attr("d",line(track))
						.attr("fill","none")
						.attr("stroke","none")
						.attr("stroke-width",0)

					var hurrPathEl = baseHurrPath.node();
					var hurrPathElLen = hurrPathEl.getTotalLength();

					var pt = hurrPathEl.getPointAtLength(0);
					
					var path_g = g.append("g")
									.attr("id","hurr");

                    var icon_g = g.append("g")
                    	.attr("transform", "translate(" + pt.x + "," + pt.y + "), scale("+(.05*track[0].class)+")")
						.attr("id","icon");
					
					var icon_bg = icon_g.append("circle")
    					.attr("r",20)
    					.attr("fill", "#ffffff")
    					.attr("class","icon");

  					var icon = icon_g.append("path")
    					.attr("d","m 20,-42 c -21.61358,0.19629 -34.308391,10.76213 -41.46346,18.0657 -7.155097,7.3036 -11.451337,17.59059 -11.599112,26.13277 0,14.45439 9.037059,26.79801 21.767213,31.69368 -14.965519,10.64929 -25.578236,6.78076 -37.671451,7.85549 C -4.429787,54.20699 14.03,37.263 23.12144,28.41572 32.2133,19.56854 34.6802,10.79063 34.82941,2.19847 c 0,-14.45219 -9.03405,-26.79679 -21.76113,-31.69364 14.90401,-10.54656 25.48889,-6.69889 37.55061,-7.77104 C 38.78869,-40.57565 29.11666,-41.95733 21.03853,-42 20.68954,-42.0105 20.34303,-42.0105 20,-42 z M 0.82306,-7.46851 c 4.72694,0 8.56186,4.27392 8.56186,9.54602 0,5.2725 -3.83492,9.54651 -8.56186,9.54651 -4.726719,0 -8.555958,-4.27401 -8.555958,-9.54651 0,-5.2721 3.829239,-9.54602 8.555958,-9.54602 z")
    
    					.attr("fill", color_scale(track[0].class))
    					.attr("class","icon");

  					var i = 0;
  
  					var animation = setInterval(function(){
      					pt = hurrPathEl.getPointAtLength(hurrPathElLen*i/track.length);
      					icon_g
        					.transition()
        					.ease("linear")							
        					.duration(500) //changed from 1000
        					.attr("transform", "translate(" + pt.x + "," + pt.y + "), scale("+(0.05*track[i].class)+"), rotate("+(i*15)+")");
      					icon
        					.transition()
        					.ease("linear")
        					.duration(500)
        					.attr("fill", color_scale(track[i].class));

      					dateText
        					.text("2013" + " " + track[i].month + " " + track[i].day + " " + track[i].hour + ":00 class: " + track[i].class)
        					.attr("fill", color_scale(track[i].class));
						
      					//Draw the path, only when i > 0 in otder to have two points
      					if (i>0){
        					color0 = color_scale(track[i-1].class);
        					color1 = color_scale(track[i].class);

        					var activatedTrack = new Array();
        
        					activatedTrack.push(track[i-1]);
        					activatedTrack.push(track[i]);

        					var color = d3.interpolateLab(color0, color1);
        					path_g.selectAll("path"+i)
        					.data(quad(sample(line(activatedTrack), 1)))
        					.enter().append("path")
          						.style("fill", function(d) { return color(d.t);})
					//			.style("stroke-dasharray", "3,2")
          						.style("stroke", function(d) { return color(d.t); })
          						.attr("d", function(d) { return lineJoin(d[0], d[1], d[2], d[3], trackWidth); });
      					}
					      	i = i + 1;
          					if (i==track.length)
            					clearInterval(animation)
  					},500);
				path_xyz = get_xyz(path_g);

				});
			
			
				// Sample the SVG path string "d" uniformly with the specified precision.
				function sample(d, precision) {
  					var path = document.createElementNS(d3.ns.prefix.svg, "path");
  					path.setAttribute("d", d);

  					var n = path.getTotalLength(), t = [0], i = 0, dt = precision;
  					while ((i += dt) < n) t.push(i);
  					t.push(n);

  					return t.map(function(t) {
    					var p = path.getPointAtLength(t), a = [p.x, p.y];
    					a.t = t / n;
    					return a;
  					});
				}

				// Compute quads of adjacent points [p0, p1, p2, p3].
				function quad(points) {
  					return d3.range(points.length - 1).map(function(i) {
    					var a = [points[i - 1], points[i], points[i + 1], points[i + 2]];
    					a.t = (points[i].t + points[i + 1].t) / 2;
    					return a;
 				 	});
				}

				// Compute stroke outline for segment p12.
				function lineJoin(p0, p1, p2, p3, width) {
  					var u12 = perp(p1, p2),
      					r = width / 2,
      					a = [p1[0] + u12[0] * r, p1[1] + u12[1] * r],
      					b = [p2[0] + u12[0] * r, p2[1] + u12[1] * r],
      					c = [p2[0] - u12[0] * r, p2[1] - u12[1] * r],
      					d = [p1[0] - u12[0] * r, p1[1] - u12[1] * r];

  					if (p0) { // clip ad and dc using average of u01 and u12
    					var u01 = perp(p0, p1), e = [p1[0] + u01[0] + u12[0], p1[1] + u01[1] + u12[1]];
    					a = lineIntersect(p1, e, a, b);
    					d = lineIntersect(p1, e, d, c);
  					}

					if (p3) { // clip ab and dc using average of u12 and u23
    					var u23 = perp(p2, p3), e = [p2[0] + u23[0] + u12[0], p2[1] + u23[1] + u12[1]];
    						b = lineIntersect(p2, e, a, b);
    						c = lineIntersect(p2, e, d, c);
  					}

  					return "M" + a + "L" + b + " " + c + " " + d + "Z";
					}

				// Compute intersection of two infinite lines ab and cd.
				function lineIntersect(a, b, c, d) {
  					var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3,
      					y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3,
      					ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
  					return [x1 + ua * x21, y1 + ua * y21];
}

				// Compute unit vector perpendicular to p01.
				function perp(p0, p1) {
  					var u01x = p0[1] - p1[1], u01y = p1[0] - p0[0],
      					u01d = Math.sqrt(u01x * u01x + u01y * u01y);
  					return [u01x / u01d, u01y / u01d];
				}	

   } 

		else {
  /*    zoom(xyz); */
			return;
    	}
	} else {
		

		g.selectAll(".boundary_zoom").classed("boundary", true);
		g.selectAll( "#" + country.id ).classed(".feature");
		d3.select("#dataTitle").remove()
		d3.select("#hurr").remove()
		d3.select("#icon").remove()
		var xyz = [width / 2, height / 2, 1];
    	country = null;
    	zoom(xyz);   
		svg.selectAll(".faceOff").classed("face",true);
		svg.selectAll(".face").classed("faceOff",false);
    
  	}
}

/*
function state_clicked(d) {
  g.selectAll("#cities").remove();

  if (d && state !== d) {
    var xyz = get_xyz(d);
    state = d;

    country_code = state.id.substring(0, 3).toLowerCase();
    state_name = state.properties.name;

    d3.json("data/json/cities_" + country_code + ".topo.json", function(error, us) {
      g.append("g")
        .attr("id", "cities")
        .selectAll("path")
        .data(topojson.feature(us, us.objects.cities).features.filter(function(d) { return state_name == d.properties.state; }))
        .enter()
        .append("path")
        .attr("id", function(d) { return d.properties.name; })
        .attr("class", "city")
        .attr("d", path.pointRadius(20 / xyz[2]));i
	g.append("g")
	

      zoom(xyz);
    });      
  } else {
    state = null;
    country_clicked(country);
  }
}
*/

/*$(window).resize(function() {
  var w = $("#map").width();
  svg.attr("width", w);
  svg.attr("height", w * height / width);

});
*/
</script>
