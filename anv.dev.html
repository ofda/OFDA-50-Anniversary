<!DOCTYPE html>
<meta charset="utf-8">

<!--
<script src="//d3js.org/d3.v3.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
-->
<style>


#heading, #context {
//font-family: "Yanone Kaffeesatz";
font-family: 'GothicBoldCond', sans-serif;
text-rendering: optimizeLegibility;
overflow-wrap: break-word;

}


#heading {
font-size: 30px;
font-weight: bold;
}

#context {
font-size: 15px;

}

#mapFrame {
margin-top:0px;
}

#seperator {
stroke: hsla(0, 0%, 50%, 1);
stroke-width: 2px; 
}

#hurr {
	stroke-dasharray: 3,2;
}

.icon {
stroke: hsla(360,0%,20%,1);
}

#countries { fill: #F8F0D9; }

.title {
	fill: hsla(0,0%,5%,.5);
	font: 20px arial, sans serif;
}
	
.background {
	fill: hsla(222, 100%, 84%, 1);
	pointer-events: all;
}

.coast {
	fill: none;
	stroke: hsl(222, 100%, 50%);
	stroke-width: .4;
}

.coast_zoom {
	fill: none;
	stroke: hsla(222, 100%, 50%, 1);
	stroke-width: .2;
}

.active {
	fill: hsla(0,67%,85%,1);
}

.active_boundary {
	fill: none;
	stroke: hsl(45,17%,73%);
	stroke-width: .1px;
}	

.featured { 
	fill: hsla(0,67%,56%,1);
}

.boundary {
	fill: none;
	stroke: hsl(45,17%,73%);
	stroke-width: 1px;
	stroke-opacity: 1;
}

.boundary_zoom {
	fill: none;
	stroke: #C6C0AE;
	stroke-width: .5px;
}

.dialogBox, .selected , .dialogBoxOff{
	margin-right: 6px;
	padding: 5px 5px;
	position: relative;
	display: inline-block;
	text-align:center;
	font-size: 30px;
	font-family: 'GothicBoldCond', sans-serif;
}
.dialogBox, .dialogBoxOff {
	color: hsla(0,0%,0%,1);
	background-color: #EDEDDD;
}

.selected {
	color: hsla(0,0%,90%,1);	
	background-color: hsla(0,0%,0%,1);
}

#swipeBox {
	background-color: hsla(0, 0%, 90%, .95);
	outline: hsla(360, 0%, 40%, .7);
	border-width: 2px; 
	padding-top, padding-bottom, padding-left, padding-right: 10px;
	white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
	white-space: -pre-wrap;      /* Opera 4-6 */
	white-space: -o-pre-wrap;    /* Opera 7 */
	white-space: pre-wrap;       /* css-3 */
	word-wrap: break-word;       /* Internet Explorer 5.5+ */
	word-break: break-all;
	white-space: normal;
	position: absolute;
	z-index:+1;
	
}


.hide {
	fill: none;
}

/*.feature {
	fill: #DA4545;
}
*/


.face {
opacity: .8;
}

.faceOff {
opacity: 0;
}

</style>

<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="http://d3js.org/colorbrewer.v1.min.js"></script>
<script src="http://d3js.org/d3.geo.projection.v0.min.js" charset="utf-8"></script>

<script>


var	width = 938,
    height = 500,
    country,
    state;
var topMargin = height * .01, 
adjust = 52;

//options needs to be created via looping through country files to determine types of content. For now created expressly
var options = ["Story","Video"];

var featured = ["PHL"];

function httpGet(theURL){
    var xmlHttp = null;
		
    xmlHttp = new XMLHttpRequest();
    xmlHttp.open( "GET", theURL, false );
    xmlHttp.send( null );
    return xmlHttp.responseText;
};


var title = "50 Years of OFDA";
var startText = "A selection of OFDA responces are highlighted in red below, click one.";

d3.select("body").append("div")
	.attr("id", "heading-Block")
	.style("padding","5px 0px")
	.style("display", "block")
	.style('clear','both')
//	.style('overflow','hidden')
	.style("backgound", "black")
	.style("width", width + "px")
	.append("div")
		.attr("id","heading")
		.style("position","relative")
		.style("width", (width * .3) + 'px')
		.text( title )
		.append("div")
			.attr("id","context")
			.style("display","inline-block")
			.style("position","absolute")
			.style('backgorund-color','#EDEDDD')
			.style("margin-left","40px")
			.style("width", (width * .65) + "px")
			.text(startText)
			.style("bottom", "2px")

		
	

	
/*d3.select("body").append("div")
	.attr("width",width)
	.attr("id","context")
	.text(startText); 
*/

var projection = d3.geo.cylindricalEqualArea()
	.parallel(35.5)
    .scale(200)
    .translate([(width)/2,( height)/ 1.9]);

var trackWidth = .5;

var color = d3.interpolateLab("#99d594", "#fc8d59");

var path = d3.geo.path()
	.projection(projection);

d3.select("body")
	.append("div")
		.attr("id","mapFrame")
		.attr("width", width)
		.attr("height", height)
	.append("div")
		.attr("id","map");

		

var svg = d3.select("body").select("#map").append("svg")
	.attr("width", width)
	.attr("height", height)
	.style("margin-top", topMargin);


svg.append("rect")
	.attr("class", "background")
	.attr("width", width)
	.attr("height", height)
	.on("click", country_clicked)
	
/*svg.append("line")
		.attr("id","seperator")
		.attr("x1", 0)
		.attr("y1", 0)
		.attr("x2", width)
		.attr("y2", 0);
	
svg.append("line")		
		.attr("id","seperator")
		.attr("x1", 0)
		.attr("y1", height + 2)
		.attr("x2", width)
		.attr("y2", height + 2);
*/

d3.select('body').select('.background').insert("div")
	.attr('id','seperator')
	.style("width", width )
	.attr('z-index',1)
	.style("position","absolute")
	.style("height", 1)
	.style("background-color", "black")
	.style("top", "0px");	

/*svg.append("rect")
	.attr("class", "background")
	.attr("width", width + margin.left + margin.right)
	.attr("height", height + margin.top + margin.bottom)
	.attr("clip-path","#clip")
	.on("click", country_clicked);
*/

var g = svg.append("g");
//	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");


/*svg.append("path")
//	g.append("g")	
	.datum(graticule)
	.attr("class","background")
	.attr("d",path);
*/

d3.json("countries_min.topo.json", function(error, us) {
		g.append("g")
		.attr("id", "countries")
		.selectAll("path")
		.data(topojson.feature(us, us.objects.countries_min).features)
		.enter()
			.append("path")
			.attr("class", function(d) {
				var c = "";
				if (featured.indexOf(d.id) > -1) {
					c = "featured";
					var centroid = path.centroid(d);
					svg.append("image")
						.attr("xlink:href","data/countries/phl/face.png")
						.attr("width", "40px")
						.attr("height", "40px")
						.attr("class", "face")	
						.attr("x", centroid[0] + 5)
						.attr("y", centroid[1] - 30) ; 
					} else {
					c = "country";
					}
					return c; 
					})
			.attr("id", function(d) { return d.id; })

			.attr("d", path)
			.on("click", country_clicked);	
		g.insert("g")
			.datum(topojson.mesh(us, us.objects.countries_min, function(a, b) {
			return a !== b; 
			}))
			.append("path")
			.attr("class", "boundary")
			.attr("d", path);
		
		g.insert("g")
			.datum(topojson.mesh(us, us.objects.countries_min, function(a, b) {
			return a === b;
			}))
			.append("path")
			.attr("class", "coast")
			.attr("d",path); 

	

		});
function zoom(xyz) {
	g.transition()
		.duration(750)
		.attr("transform", "translate(" + projection.translate() + ")scale(" + xyz[2] + ")translate(-" + xyz[0] + ",-" + xyz[1] + ")")
		.selectAll(["#countries", "#states"])
		.style("stroke-width", 1.0 / xyz[2] + "px")
		.selectAll(".city")
		.attr("d", path.pointRadius(20.0 / xyz[2]));


		g.select(".boundary").classed("boundary_zoom",true);
		g.select(".boundary_zoom").classed("boundary",false);
		g.select(".coast").classed("coast_zoom",true);
		g.select(".coast_zoom").classed("coast",false);


}


function get_xyz(d) {
	var bounds = path.bounds(d);
	var w_scale = (bounds[1][0] - bounds[0][0]) / width;
	var h_scale = (bounds[1][1] - bounds[0][1]) / height;
	var z = .96 / Math.max(w_scale, h_scale);
	var x = (bounds[1][0] + bounds[0][0]) / 2;
	var y = (bounds[1][1] + bounds[0][1]) / 2 + (height / z / 6);
	return [x, y, z];
}



function country_clicked(d) {
	g.selectAll(["#states"]).remove();
	state = null;

	if (country) {
		g.selectAll( "#" + country.id ).style('display', null);

	}	

	if (d && country !== d) {
		var xyz = get_xyz(d);
		country = d;



		if ( d.id == 'PHL') {
		svg.selectAll(".face").classed("faceOff",true).classed('face',false);

		function getHTTP(id) {
			
			d3.select("#map").append("div")
				.attr("id","swipeBox")
				.attr("height", "0px")
				.style("width",width + "px")
				.attr("top", height + adjust +  "px")
				.style("opacity", 0)
				.html(function () {
						var text
						if (id ===  "Video") {
						 	text =  "<iframe width=\"" + width + "\" height=\"" + height + "\" src=\"//www.youtube.com/embed/HaEbhGiCVT8\" frameborder=\"0\" allowfullscreen></iframe>";
						} else if (id === "Story") {
							text = "<iframe width=\"" + width + "\" height=\"" + height + "\" src=\"data/countries/" + d.id.toLowerCase() + "/stories/Jeremy_Konyndyk/text.html\"></iframe>";
						}
					return text;
				 	})//put up information screen

				.transition()
				.delay(800)
				.style("height", height + "px")	
				.style("top", (topMargin + adjust) + "px")
				.style('opacity', 1);
			}
		
	
//		var  dialogClosed = true;
		d3.select("#map").append("div")
			.attr("id","dialogBoxContainer")
			.selectAll("div")
			.data(options)
			.enter()
			.insert("div")
			.attr("class", "dialogBox dialogBoxOff")
			.style('opacity', 0)
			.transition()
			.ease("linear")
			.delay(750)
			.each("start", function() {d3.select(this).style("height",0);})
			.text(function (d) { return d; })
			.style("height","36px")
			.style('opacity', 1)
			.attr('id', function(d) { return d; })
			.style("top",height);

		d3.select('#map').selectAll('.dialogBoxOff')
			.on("click", function () {
				alert(d3.select(this).attr("class"))
				if (d3.select(this).classed("dialogBoxOff")) {
					d3.select("#map").select("#swipeBox").remove();
					d3.select("#map").selectAll(".dialogBox").classed("selected",false).classed('dialogBoxOff', true);
					var id = this.id;
					getHTTP(id);
					d3.select(this).classed("selected", true).classed("dialogBoxOff",false);
				} else if(d3.select(this).classed("selected")) {
					d3.select("#map").select("#swipeBox").remove();
						
					d3.select(this).classed("dialogBoxOff",true).classed('selected',false);
		
				} 
			});
	




		d3.select("#context").text("Typhoon Haiyan/Yolanda made landfall in the Philippines, bringing strong winds and heavy rains that resulted in flooding, landslides, and widespread damage.");





		g.selectAll( "#" + country.id ).classed(".hide");
			
		d3.json("data/json/states_" + d.id.toLowerCase() + ".topo.json", function(error, us) {
			g.append("g")
          			.attr("id", "states")
          			.selectAll("path")
          			.data(topojson.feature(us, us.objects.states).features)
          			.enter()
          			.append("path")
          			.attr("id", function(d) { return d.id; })
          			.attr("class", "active")
          			.attr("d", path)
  					/*  .on("click", state_clicked);     */
					var hurrZoomFactor = [1,1,.5];
					for(var i=0; i < hurrZoomFactor.length; i++) {
						xyz[i] = hurrZoomFactor[i] * xyz[i];
					}

				g.insert("g")
					.datum(topojson.mesh(us, us.objects.states, function(a, b) {
						return a !== b; 
					}))
					.append("path")
					.attr("class", "active_boundary")
					.attr("d", path);
        		zoom(xyz);

  //      		g.selectAll("#" + d.id).style('display', 'none');
      		});      

			

			d3.json("data/countries/" + d.id.toLowerCase() + "/track.json", function(error, track) {

					var color_scale = d3.scale.quantile().domain([3,5]).range(colorbrewer.Reds[5]);
					

					var dateText = svg.append("text")
						.attr("id", "dataTitle")
						.text("2013" + " " + track[0].month + " " + track[0].day + " " + track[0].hour + ":00 class: " + track[0].class)
						.attr("x", 650)
						.attr("y", 20)
						.attr("font-family", "sans-serif")
						.attr("font-size", "20px")
						.attr("fill", color_scale(track[0].class));

					var line = d3.svg.line()
						.interpolate("cardinal")
						.x(function(d) {return projection([d.lon, d.lat])[0]; })
						.y(function(d) {return projection([d.lon, d.lat])[1]; });

					var baseHurrPath = svg.append("path")
						.attr("d",line(track))
						.attr("fill","none")
						.attr("stroke","none")
						.attr("stroke-width",0)

					var hurrPathEl = baseHurrPath.node();
					var hurrPathElLen = hurrPathEl.getTotalLength();

					var pt = hurrPathEl.getPointAtLength(0);
					
					var path_g = g.append("g")
									.attr("id","hurr");

                    var icon_g = g.append("g")
                    	.attr("transform", "translate(" + pt.x + "," + pt.y + "), scale("+(.05*track[0].class)+")")
						.attr("id","icon");
					
					var icon_bg = icon_g.append("circle")
    					.attr("r",20)
    					.attr("fill", "#ffffff")
    					.attr("class","icon");

  					var icon = icon_g.append("path")
    					.attr("d","m 20,-42 c -21.61358,0.19629 -34.308391,10.76213 -41.46346,18.0657 -7.155097,7.3036 -11.451337,17.59059 -11.599112,26.13277 0,14.45439 9.037059,26.79801 21.767213,31.69368 -14.965519,10.64929 -25.578236,6.78076 -37.671451,7.85549 C -4.429787,54.20699 14.03,37.263 23.12144,28.41572 32.2133,19.56854 34.6802,10.79063 34.82941,2.19847 c 0,-14.45219 -9.03405,-26.79679 -21.76113,-31.69364 14.90401,-10.54656 25.48889,-6.69889 37.55061,-7.77104 C 38.78869,-40.57565 29.11666,-41.95733 21.03853,-42 20.68954,-42.0105 20.34303,-42.0105 20,-42 z M 0.82306,-7.46851 c 4.72694,0 8.56186,4.27392 8.56186,9.54602 0,5.2725 -3.83492,9.54651 -8.56186,9.54651 -4.726719,0 -8.555958,-4.27401 -8.555958,-9.54651 0,-5.2721 3.829239,-9.54602 8.555958,-9.54602 z")
    
    					.attr("fill", color_scale(track[0].class))
    					.attr("class","icon");

  					var i = 0;
  
  					var animation = setInterval(function(){
      					pt = hurrPathEl.getPointAtLength(hurrPathElLen*i/track.length);
      					icon_g
        					.transition()
        					.ease("linear")							
        					.duration(500) //changed from 1000
        					.attr("transform", "translate(" + pt.x + "," + pt.y + "), scale("+(0.05*track[i].class)+"), rotate("+(i*15)+")");
      					icon
        					.transition()
        					.ease("linear")
        					.duration(500)
        					.attr("fill", color_scale(track[i].class));

      					dateText
        					.text("2013" + " " + track[i].month + " " + track[i].day + " " + track[i].hour + ":00 class: " + track[i].class)
        					.attr("fill", color_scale(track[i].class));
						
      					//Draw the path, only when i > 0 in otder to have two points
      					if (i>0){
        					color0 = color_scale(track[i-1].class);
        					color1 = color_scale(track[i].class);

        					var activatedTrack = new Array();
        
        					activatedTrack.push(track[i-1]);
        					activatedTrack.push(track[i]);

        					var color = d3.interpolateLab(color0, color1);
        					path_g.selectAll("path"+i)
        					.data(quad(sample(line(activatedTrack), 1)))
        					.enter().append("path")
          						.style("fill", function(d) { return color(d.t);})
          						.style("stroke", function(d) { return color(d.t); })
          						.attr("d", function(d) { return lineJoin(d[0], d[1], d[2], d[3], trackWidth); });
      					}
					      	i = i + 1;
          					if (i==track.length)
            					clearInterval(animation)
  					},500);
				path_xyz = get_xyz(path_g);

				});
			
			
				// Sample the SVG path string "d" uniformly with the specified precision.
				function sample(d, precision) {
  					var path = document.createElementNS(d3.ns.prefix.svg, "path");
  					path.setAttribute("d", d);

  					var n = path.getTotalLength(), t = [0], i = 0, dt = precision;
  					while ((i += dt) < n) t.push(i);
  					t.push(n);

  					return t.map(function(t) {
    					var p = path.getPointAtLength(t), a = [p.x, p.y];
    					a.t = t / n;
    					return a;
  					});
				}

				// Compute quads of adjacent points [p0, p1, p2, p3].
				function quad(points) {
  					return d3.range(points.length - 1).map(function(i) {
    					var a = [points[i - 1], points[i], points[i + 1], points[i + 2]];
    					a.t = (points[i].t + points[i + 1].t) / 2;
    					return a;
 				 	});
				}

				// Compute stroke outline for segment p12.
				function lineJoin(p0, p1, p2, p3, width) {
  					var u12 = perp(p1, p2),
      					r = width / 2,
      					a = [p1[0] + u12[0] * r, p1[1] + u12[1] * r],
      					b = [p2[0] + u12[0] * r, p2[1] + u12[1] * r],
      					c = [p2[0] - u12[0] * r, p2[1] - u12[1] * r],
      					d = [p1[0] - u12[0] * r, p1[1] - u12[1] * r];

  					if (p0) { // clip ad and dc using average of u01 and u12
    					var u01 = perp(p0, p1), e = [p1[0] + u01[0] + u12[0], p1[1] + u01[1] + u12[1]];
    					a = lineIntersect(p1, e, a, b);
    					d = lineIntersect(p1, e, d, c);
  					}

					if (p3) { // clip ab and dc using average of u12 and u23
    					var u23 = perp(p2, p3), e = [p2[0] + u23[0] + u12[0], p2[1] + u23[1] + u12[1]];
    						b = lineIntersect(p2, e, a, b);
    						c = lineIntersect(p2, e, d, c);
  					}

  					return "M" + a + "L" + b + " " + c + " " + d + "Z";
					}

				// Compute intersection of two infinite lines ab and cd.
				function lineIntersect(a, b, c, d) {
  					var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3,
      					y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3,
      					ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
  					return [x1 + ua * x21, y1 + ua * y21];
				}

				// Compute unit vector perpendicular to p01.
				function perp(p0, p1) {
  					var u01x = p0[1] - p1[1], u01y = p1[0] - p0[0],
      					u01d = Math.sqrt(u01x * u01x + u01y * u01y);
  					return [u01x / u01d, u01y / u01d];
				}	
   		} 

		else {		

			zoom(xyz); 
			return;
    	}
	} else {
		d3.select("#dataTitle").remove()
		d3.select("#hurr").remove()
		d3.select("#icon").remove()
		var xyz = [width / 2, height / 2, 1];
    	country = null;
    	zoom(xyz);
		d3.select("#context").text(startText); 
		d3.selectAll(".dialogBox").remove();
		svg.selectAll(".faceOff").classed("face",true);
		svg.selectAll(".face").classed("faceOff",false);
 		g.selectAll(".coast_zoom").classed("coast", true);
		g.selectAll(".coast").classed("coast_zoom", false);  		
		g.select(".boundary_zoom").classed("boundary", true);
		g.select(".boundary").classed("boundary_zoom", false);
		g.selectAll( "#" + country.id ).classed("feature", true); 
  	}
}

/*
function state_clicked(d) {
  g.selectAll("#cities").remove();

  if (d && state !== d) {
    var xyz = get_xyz(d);
    state = d;

    country_code = state.id.substring(0, 3).toLowerCase();
    state_name = state.properties.name;

    d3.json("data/json/cities_" + country_code + ".topo.json", function(error, us) {
      g.append("g")
        .attr("id", "cities")
        .selectAll("path")
        .data(topojson.feature(us, us.objects.cities).features.filter(function(d) { return state_name == d.properties.state; }))
        .enter()
        .append("path")
        .attr("id", function(d) { return d.properties.name; })
        .attr("class", "city")
        .attr("d", path.pointRadius(20 / xyz[2]));i
	g.append("g")
	

      zoom(xyz);
    });      
  } else {
    state = null;
    country_clicked(country);
  }
}
*/

/*$(window).resize(function() {
  var w = $("#map").width();
  svg.attr("width", w);
  svg.attr("height", w * height / width);

});
*/
</script>
